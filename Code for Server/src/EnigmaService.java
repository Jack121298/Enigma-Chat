//Name: Jack Kelvin
//Student Number: z5413924
//Course: COMP6841


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

public class EnigmaService
{
    //constructor for Enigma Service
    public EnigmaService()
    {
        currentSetting = null;//set variable, currentSetting, to null which stores all settings generated by this class
    }

    //return currentSetting variable to caller of method
    public String getCurrentSetting()
    {
        return Arrays.toString(currentSetting);
    }


    //generates settings for the enigma machine
    //generates rotor selection, rotor starting positions, rotor ring settings, reflector settings and plug board pairs
    public void generateSetting()
    {
        //arrays of settings for each particular setting generated randomly by their respective functions
        int[] rss = getRotorSelectionSettings();//stores rotor selection, size of 3, chooses 3 out of 5
        int[] rprs = getRotorPosAndRingSettings();//stores rotor positions and ring settings, size of 6, value matches specific letter in alphabet - a = 0, z = 25
        int ref = getReflectorSetting();//integer to store reflector settings which is either 0 for UKW-B or 1 for UKW-C,
        int[] pbs = getPlugBoardSettings();//array that stores plugboard settings, minimum size of 0, max of 20 for 10 pairs. Stored where index i = some letter and index i + 1 = another letter
        //both are pairs that explain an equivalence. AB means that B input becomes A and A input becomes B

        int[] combinedRSS_RPRS = new int[rss.length + rprs.length + 1];//new array to merge RSS, RPRS and Ref settings. Merging three arrays at once gave some weird results. Size = 2 arrays + value for integer

        System.arraycopy(rss, 0, combinedRSS_RPRS, 0, rss.length);//copy of array RSS from index = 0 to rss.length amount into combinesRSS_RPRS array
        System.arraycopy(rprs, 0, combinedRSS_RPRS, rss.length, rprs.length);//copy of array RPRS from index = rss.length amount to rprs.length amount into combinesRSS_RPRS array

        combinedRSS_RPRS[rss.length + rprs.length] = ref;//allocate last position of the combinesRSS_RPRS array to store reflector setting which is single variable and not an array

        int[] combinedTotal = new int[combinedRSS_RPRS.length + pbs.length];//new array of size combinesRSS_RPRS array size + pbs array size

        System.arraycopy(combinedRSS_RPRS, 0, combinedTotal, 0, combinedRSS_RPRS.length);//copy combinesRSS_RPRS array from 0 to combinesRSS_RPRS array size. Save to combinedTotal
        System.arraycopy(pbs, 0, combinedTotal, combinedRSS_RPRS.length, pbs.length);//copy pbs array from combinesRSS_RPRS array size to pbs size. Save to combinedTotal

        currentSetting = combinedTotal;//save combinedTotal to class variable of currentSetting
    }

    //returns an array for rotor settings
    public int[] getRotorSelectionSettings()
    {
        //needed a way to remove options from random selection so that duplicates didn't exist
        //arraylist to dynamically resize was optimal
        //stores integers where the integer corresponds to the exact rotor, integer 0 = rotor I, integer 4 = rotor V
        ArrayList<Integer> rotors = new ArrayList<>();
        //new array to store the chosen rotors for the next settings
        int[] rotorSelection = new int[3];
        for(int i = 0; i < 5; i++)//fill arraylist at index i with a value of index i so that index 0 = 0
        {
            rotors.add(i, i);
        }
        Random rand = new Random();//random rand allows for a new random number to provided with some sort of bound
        for(int i = 0; i < 3; i++)//do 3 times for each rotor slot in the machine
        {
            int rotor = rand.nextInt(rotors.size());//rotor is assigned value outputted by the random.nextInt() function which has been provided a bound of size 5, Generates numbers from 0 to 4
            rotorSelection[i] = rotors.remove(rotor);//remove rotor at index 'rotor' and place in the array at index i; Size of arraylist has been decreased and so now the rand function can only produce numbers of a smaller bound
        }
        return rotorSelection;//return arraylist
    }

    //Function to produce settings for rotor and ring of a particular wheel. index 0 to 2 is for starting settings, index 3 to 5 is for ring settings
    //index at 0 corresponds to rotorPos for rotor in the left most slot of the machine
    //index at 3 corresponds to ringSetting for rotor in the left most slot of the machine
    //stores letters in their numerical order - 1. 0 -> A, 25 -> Z
    public int[] getRotorPosAndRingSettings()
    {
        int[] data = new int[6];//new array of size 6
        Random rand = new Random();//new random function
        for(int i = 0; i < 6; i++)//loop 6 times
        {
            data[i] = rand.nextInt(26);//fill array at index i from 0 to 6 with a number from 0 to 25
        }
        return data;//return that array
    }

    //generates a number from 0 to 1 and returns as an integer
    //0 -> UKW-B
    //1 -> UKW-C
    public int getReflectorSetting()
    {
        Random rand = new Random();//new random function
        return rand.nextInt(2);//return result of next int call bounded by 2 which generates an integer from 0 to 1
    }


    //produces an array of settings for the plugboard that can be of size 0 to size 20
    //index at 0 and index at 1 are a pair. index at 2 and 3 are a pair.....and so on
    //has an array list as we can't dynamically have any choices be duplicates. No transitivity!
    //this means that 'A' can't map to 'T' and then 'T' maps to some other letter. Also means that 2 letters being a pair prevents them from being used again, similar to rotor selection settings
    //Numerical form means that A = 0, B = 1, ... Z = 25
    public int[] getPlugBoardSettings()
    {
        ArrayList<Integer> letters = new ArrayList<>();//store letters in an arraylist to store letters in numerical form
        for(int i = 0; i < 26; i++)
        {
            letters.add(i, i);//at index i, starting from 0, add i as the value.
        }
        Random rand = new Random();//new random function for numbers to be slotted into the array
        int numberOfLetters = rand.nextInt(11)*2;//Used for how many settings to have. Bounded at 11, means we can have 10 pairs of numbers. This is then given to an array which gets made to be the size of the value multiplied by 2 to store the entire thing
        int[] data = new int[numberOfLetters];//new array of size 'numberOfLetters' which is then used to store the pairs
        for(int i = 0; i < numberOfLetters; i++)//loop through array
        {
            int letter = rand.nextInt(letters.size());//allocate next letter, bounded by the letter's arraylist's size
            data[i] = letters.remove(letter);//assign the letter at 'I' by removing the letter stored in the letters arraylist
        }
        return data;//return the array
    }


    //private member data
    private int[] currentSetting;//stores current setting in an array produced by the above methods


}
